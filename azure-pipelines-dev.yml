# Docker image.
# Build a Docker image to deploy, run, or push to a container registry.
# Add steps that use Docker Compose, tag images, push to a registry, run an image, and more:
# https://docs.microsoft.com/azure/devops/pipelines/languages/docker

name: $(SourceBranchName)_$(date:yyyyMMdd)
pool:
  vmImage: 'Ubuntu-16.04'

stages:
- stage: Build
  displayName: 'Build from Develop'

  jobs:
  - job: GetVersion
    displayName: Get Version
    steps:
    - bash: |
        VERSIONT=$(jq -r .version package.json)
        echo "##vso[task.setvariable variable=version;isOutput=true]$VERSIONT"     
      name: App 

  - job: Build
    displayName: Build 
    dependsOn: GetVersion
    variables:
      appVersion: $[ dependencies.GetVersion.outputs['App.version'] ]
      buildIncrement: $[counter(variables['appVersion'], 0)] # create a counter that is used to increment build run for same app version
      buildVersion: "$(appVersion)-r$(buildIncrement)"
    steps:
    - bash: echo "##vso[build.updatebuildnumber]$(buildVersion)" # Update build number in Pipeline UI
      displayName: Update build number   

  # Login into Azure
    - task: Docker@1
      displayName: Login into Azure container registry
      condition: always()
      inputs:
        command: login
        azureSubscriptionEndpoint: $(azureSubscriptionContainerRegistry)
        azureContainerRegistry: $(azureContainerRegistry)

    # Setting name, commit and date
    - task: Bash@3
      displayName: Setting name, commit and date
      inputs:
        targetType: 'inline'
        script: |
          echo "##vso[task.setvariable variable=NAMET]$(jq -r .name package.json)"
          echo "##vso[task.setvariable variable=COMMITT]$(git log -1 --format=%H)"
          echo "##vso[task.setvariable variable=DATET]$(date +%F)"

    # Build image
    - task: Docker@1
      displayName: Build image
      inputs:
        command: build
        azureSubscriptionEndpoint: $(azureSubscriptionContainerRegistry)
        azureContainerRegistry: $(azureContainerRegistry)    
        dockerFile: Dockerfile
        arguments: --build-arg NAMET=$(NAMET) --build-arg VERSIONT=$(buildVersion) --build-arg COMMITT=$(COMMITT) --build-arg DATET=$(DATET)
        imageName: $(Build.Repository.Name):v$(buildVersion)

    # Perform TESTS
    - task: Docker@1
      displayName: 'Running unit tests'
      inputs:
        azureSubscriptionEndpoint: $(azureSubscriptionContainerRegistry)
        azureContainerRegistry: $(azureContainerRegistry)
        imageName: $(azureContainerRegistry)/$(Build.Repository.Name):v$(buildVersion)    
        command: run
        containerName: unittests
        volumes: '$(Build.Repository.LocalPath):/app/test_results'    
        workingDirectory: /app
        containerCommand: 'npm run unit-tests'
        runInBackground: false

    # Upload Tests Results to Analytics 
    - task: PublishTestResults@2
      displayName: 'Publish Test Results unit-test-results.xml'
      inputs:
        testResultsFiles: '$(Build.Repository.LocalPath)/unit-test-results.xml'
        testRunTitle: 'Unit Tests Results Upload'
      continueOnError: true
      condition: succeededOrFailed()

    # Push this new image to container registry
    - task: Docker@1
      displayName: Push image to Azure container registry
      inputs:
        command: push
        azureSubscriptionEndpoint: $(azureSubscriptionContainerRegistry)
        azureContainerRegistry: $(azureContainerRegistry)
        imageName: $(Build.Repository.Name):v$(buildVersion)

    # Logout after all tasks finished
    - task: Docker@1
      displayName: Logout Azure container registry
      condition: always()
      inputs:
        command: logout
        azureSubscriptionEndpoint: $(azureSubscriptionContainerRegistry)
        azureContainerRegistry: $(azureContainerRegistry)

    # sleep until release
    # Sleep 10 seconds
    - bash: |
        sleep 10   
      displayName: Wait till Image is Up

- stage: Deploy_Dev
  displayName: 'Deploy to Dev'
  jobs:

  - job: Integration_Migration
    displayName: 'Integration and Migration'
    steps:

    - task: AzureKeyVault@1
      displayName: 'Azure Key Vault: boa-auth-kv-$(Release.EnvironmentName)'
      inputs:
        azureSubscription: $(azureSubscriptionEndpoint)
        KeyVaultName: '$(KeyVaultDev)'

  # Login into Azure
    - task: Docker@1
      displayName: Login into Azure container registry
      condition: always()
      inputs:
        command: login
        azureSubscriptionEndpoint: $(azureSubscriptionContainerRegistry)
        azureContainerRegistry: $(azureContainerRegistry)

    - task: DockerCompose@0
      displayName: 'Migration local sql-server'
      inputs:
        dockerComposeFile: '$(System.DefaultWorkingDirectory)/db/docker-compose.testdb.yml'
        dockerComposeCommand: 'up --build -d'
    - task: Bash@3
      inputs:
        targetType: 'inline'
        script: 'sleep 10'

    - task: AzureCLI@1
      displayName: 'Integration Test'
      inputs:
        azureSubscription: $(azureSubscriptionEndpoint)
        scriptLocation: inlineScript
        inlineScript: |
         keyvaultname=$(KeyVaultDev)
         dockerimage=elevacontainerregistry.azurecr.io/$(Build.Repository.Name):v$(Build.BuildNumber)
         values="$(az keyvault secret list --vault-name $keyvaultname --query '[*].id' -o tsv)"
         for item in $values
         do
           items=${item##*/} 
           secretstore=$(az keyvault secret show --vault-name $keyvaultname --name $items --query value -o tsv)
           valuestore=${items//[-]/_}
           echo $valuestore=$secretstore
         done >> $keyvaultname.env 
         docker run --net=netest --env-file $keyvaultname.env  -v $(System.DefaultWorkingDirectory):/app/test_results $dockerimage npm run integration-tests
    
    - task: PublishTestResults@2
      displayName: 'Publish Integration Test Results'
      inputs:
        testResultsFiles: 'integration-test-results.xml'
        failTaskOnFailedTests: true


    
  

    


    




  